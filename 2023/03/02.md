# 取り組んだ課題一覧
- ruby
## わかったこと
- `yield`メソッドの呼び出し時に渡されたブロックを実行
- ブロックがないのにyieldでブロックを呼び出そうとするとエラー
- `block_given?`ブロックが渡されているか
- `def メソッド(&引数)`ブロックを引数として受け取る
  - `引数.call`ブロックの実行
  - そのメソッド内で他のメソッドを呼び出す際にブロックを引数として渡せる
- ブロックは処理の塊
- ブロックをオブジェクトにするクラスがProc
- 引数のブロックはProcオブジェクト
- これを応用してブロックの代わりにProcオブジェクトを引数にできる
- Procオブジェクトを引数にする際はメソッドの定義に`&`があるかで引数が変わる
- メソッドが受け取れるブロックの最大は1つだが、普通の引数としてProcオブジェクト渡す場合は複数可
```
# 同義
Proc.new{|a,b|a+b}
proc{|a,b|a+b}
->(a,b){a+b}
lambda{|a,b|a+b}
```
上2つとした2つは引数に過不足による挙動の違いがある
- `lamda?`lamdaとして作られたオブジェクトならtrue
- シンボルは`to_proc`メソッドを持つ
- このProcオブジェクトはcallメソッドの際に第1引数をレシーバ、第2引数をメソッドの第1引数にする
- `map(&:upcase)`
①&:upcaseはシンボルの:upcaseに対してto_procメソッドを呼び出す。
②シンボルの:upcaseがProcオブジェクトに変換され、mapメソッドにブロックとして渡される。
③上記②で作ったProcオブジェクトはmapメソッドから配列の各要素を実行時の第1引数として受け取る。第1引数はupcaseメソッドのレシーバとなる。つまり、配列の各要素に対してupcaseメソッドを呼び出す。
④mapメソッドはProcオブジェクトの戻り値を順に新しい配列に詰め込む。
⑤上記③と④のコンビネーションにより、配列の各要素が大文字に変換された新しい配列がmapメソッドの戻り値になる。
- メソッドの引数やローカル変数がProcオブジェクトの場合、引き続き参照できる
- パターンマッチ
  - case/in
  - `in[変数1, 変数2, ...]`caseの後の配列の要素が代入される
  - inの中の変数の数によって該当する配列が変化する
  - 要素数が同じなら、keyを指定する
  - in節で値を省略した場合、自動的にkeyと同じ名前のローカル変数が作られ、そこに値が代入される
  - case文同様、値を返すため、代入やメソッドの返り値として使える
  - thenを使って条件にマッチしたときの処理を1行で書ける点もcase文と同じ
  - パターンが1つもマッチしない場合例外を返す
  - `in[*変数]`任意の要素数
  - `in[変数,]上と同義
  - hashパターンはハッシュの各要素がin節で指定したパターン（キーと値、またはキーのみ）に部分一致すればマッチしたと判定される
  - そのため、順番に注意

# 次やること

# 感じたこと



### 学習時間
- Today: 4h
- Total: 54h