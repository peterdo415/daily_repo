# 取り組んだ課題一覧
- ruby
## わかったこと
- クラス内部のメソッドはインスタンスメソッド
- その中で@で定義されるのはインスタンス変数
- インスタンス変数は同じインスタンス内部で共有、クラス内で使える
- ローカル変数は最初に値を入れなければエラー
- まだないインスタンス変数を参照した場合はnil
- インスタンス変数は外部から参照できない
  - 参照するにはそれ用のメソッドが必要
  - ゲッターメソッド
- インスタンス変数を外部から変更
  - `メソッド=()`
  - セッターメソッド
- セッターとゲッターを省略できるのがattr_accessorメソッド
  - 自動でアクセサメソッドを設定
  - 読み取り専用にする場合はattr_readerメソッド
  - 書き込みのみはattr_writer
- インスタンス変数はインスタンスに含まれるデータ
- それらそれら読み書きするのがインスタンスメソッド
- そのクラスに関連は深いものの、ひとつひとつのインスタンスに含まれるデータは使わないメソッドを定義
  - クラスメソッド
    - `self.メソッド名`または`class << self`,`def メソッド名`
    - `クラス名.メソッド名`で呼び出し
- 定数は全て大文字
  - インスタンスメソッド内でもクラスメソッド内でも参照可
- セッターメソッドの呼び出しにはselfが必要
- クラスメソッドをインスタンスメソッドから呼び出すには`self.class.メソッド名`の時もある
- 継承元を指定せずに作成したクラスはデフォでObjectクラスを継承
- サブクラスでスーパークラスと同名のメソッドを定義するとオーバーライドされる
- initializeメソッド以外のインスタンスメソッドはデフォルトでpublicメソッド
- privateメソッドはサブクラスからから呼び出せる
- オーバーライドの際は可視性もオーバーライドできる
- クラスメソッドをprivateにするには`class << self`内にprivate
- もしくは`private_class_method: self.の後のメソッド名`
- protect
  - 外部には公開したくないが、同じクラスやサブクラスの中であればレシーバ付きで呼び出せるようにしたい
  - ruby3.0以降ならattr_readerでいい
- `クラス名::定数`で定数参照
- `private_constant:定数`で外部から参照されない
- 定数はクラス構文直下に
- 定数定義はそれ自体が値を返す
- 定数は再代入できる
- それを阻止するには`クラス.freeze`
- freezeの深度は規模による
- インスタンス変数はオブジェクトごとに、クラスインスタンス変数はクラス自体が保持
  - クラス直下やクラスメソッド内のインスタンス変数はクラスインスタンス変数にあたる
  - そのため継承してもクラスごとに保持するクラスインスタンスメソッドは同名でも区別される
- `$変数名`グローバル変数、プログラムのどこからでも参照可
- `alias 新しい名前 元の名前`エイリアスメソッドの定義
  - 元のメソッドが定義されていないとエラー
- Rubyでは演算子もメソッドとして再定義できる
- `オブジェクト.メソッド`特定のオブジェクトにのみ紐づくメソッドを特異メソッド
- オブジェクトのクラスが何であろうとそのメソッドが呼び出せれば良しとするプログラミングスタイルのことを「ダックタイピング（ducktyping）」と呼ぶ
- モジュール
  - ・モジュールからインスタンスを作成することはできない。・ほかのモジュールやクラスを継承することはできない。
  - `module 名前`で定義
  - クラス内で`include module名`でインスタンスメソッドとして使えるように
  - ミックスイン、モジュールをクラスにincludeして機能を追加すること
  - module側でprivateメソッドを使えばprivateに
  - メソッドを実行する瞬間にそのメソッドが呼び出せれば良いためinclude先で定義されているメソッド前提でmoduleのメソッドを作っていい
  - クラス内で`extend module名`とするとmoduleをクラスメソッドにできる
  - module内で`クラス.include module名`でもincludeできる
  - includeされたモジュールの有無を確認
    - `クラス.include?(module)`
    - `クラス.include_modules`
  - トップレベル
    - Rubyではクラス構文やモジュール構文に囲まれていない一番外側の部分のこと
    - Objectクラスのインスタンス
  - moduleがmodule先のインスタンス変数を参照するのはあまり良くない
  - そのためインスタンス変数ではなくインスタンスメソッドを参照する
  - module内にクラスを定義し、その中にメソッドを定義
    - 同名クラス名でもmoduleが違うと同名のクラス名を区別できる
    - module名::クラス名
  - `class module名::クラス名`でnamespace付きのクラス定義
  - `module_function :メソッド`ミックスインでも特異メソッドでも使える, モジュール関数と呼ぶ, ミックスインするとprivateに
  - `モジュール名.#メソッド名`モジュール関数の表記法
  - モジュールにモジュールをincludeすることもできる
- 例外
  - `rescue => 例外オブジェクトオブジェクトを格納する変数`
  - `message`メソッドで例外発生時のエラーメッセージを返す
  - `backtrace`メソッドはバックトレース情報（つまりメソッドの呼び出し履歴）を配列にして返す
  - `rescue 捕捉したい例外クラス => 変数`
  - rescueを複数書くことも可
  - rescueに複数のクラスを指定することも可能
  - 通常のエラーのスーパクラスはStandardError
  - それを継承していない特署なエラーは捕捉できない
  - rescueは上から処理されていくのでサブクラスから書いていく
  - rescue内で`retry`で例外発生時にbeginから
    - 回数を決めないと無限ループするので、カウンタ変数を用意する
  - `raise`で意図的に例外を発生
  - `raise "文字列"`文字列がエラーメッセとなる
    - RuntimeErrorクラスの例外が発生
    - 第1引数に例外クラスにするとRuntimeError以外のエラーになる
  - 原則、例外が発生してもrescueしない
  - rescueしたら情報を残す
  - 例外処理よりも条件分岐
    - elseでraiseを使う
  - `ensure`例外の有無に関わらず実行する処理
  - メソッドにブロック渡してクローズ処理をさせる
  - `例外が発生しそうな処理rescue例外が発生したときの戻り値`begin/endを省略
  - rescue内でraiseするとプログラム自体は以上終了させるが、情報を残したい場合


# 次やること

# 感じたこと
- インスタンスの操作がないものはモジュール

### 学習時間
- Today: 3.5h
- Total: 49h